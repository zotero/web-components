import { log as logger } from '../Log.js';
var log = logger.Logger('PayInvoice', 1);

import { useState, useReducer, useContext } from 'react';
import PropTypes from 'prop-types';
import { Alert, Card, CardHeader, CardBody, Row, Col } from 'reactstrap';

import { ErrorWrapper } from '../components/ErrorWrapper.jsx';
import { Notifier } from '../Notifier.js';
import { priceCents, labPrice, labUserPrice } from './calculations.js';
import { CardPaymentModal, MultiPaymentModal } from './PaymentModal.jsx';
import { PaymentSource } from './PaymentSource.jsx';

import { ajax } from '../ajax.js';
import { LoadingSpinner } from '../LoadingSpinner.js';
import { formatCurrency } from '../Utils.js';
import { StorageContext, PaymentContext, paymentReducer } from './actions.js';

const dateFormatOptions = { year: 'numeric', month: 'long', day: 'numeric' };

const storageLevelDescriptions = {
	2: '2 GB',
	3: '6 GB',
	6: 'Unlimited storage'
};

/*
async function chargeInvoice(invoiceID = false, token = false) {
	if (!invoiceID) {
		throw new Error('no invoiceID specified');
	}
	if (token === false) {
		throw new Error('no token for chargeInvoice');
	}
	
	try {
		let data = {
			invoiceID,
			stripeToken: token.id
		};
		let resp = await postFormData('/storage/chargeinvoice', data, { withSession: true });
		
		log.debug(resp);
		if (resp.ok) {
			let respData = await resp.json();
			return {
				type: 'success',
				message: <span>Invoice Paid</span>,
				data: respData
			};
		} else {
			throw resp;
		}
	} catch (resp) {
		log.error(resp);
		
		try {
			let data = await resp.json();
			if (data.stripeMessage) {
				return { type: 'error', message: `There was an error processing your payment: ${data.stripeMessage}` };
			} else {
				return { type: 'error', message: 'Error updating subscription. Please try again in a few minutes.' };
			}
		} catch (e) {
			return { type: 'error', message: 'Error updating subscription. Please try again in a few minutes.' };
		}
	}
}
*/

// component that handles paying an invoice that has been generated by a user for a third party to pay
function PayInvoice(props) {
	const { invoice, invoiceUser, institutionName, overQuota } = props;
	const { invoiceID, invoiceType, stripeCharge, numUsers, storageLevel, created } = invoice;
	
	// const { notifyDispatch } = useContext(NotifierContext);
	// const { paymentDispatch, paymentState } = useContext(PaymentContext);
	const [paymentState, paymentDispatch] = useReducer(paymentReducer, {
		stripeCustomer: props.stripeCustomer,
	});
	
	const [stripeChargeObject, setStripeChargeObject] = useState(props.stripeChargeObject);
	
	const [invoicePaid, setInvoicePaid] = useState(!!stripeCharge);
	const { paymentIntent } = paymentState;
	
	let description = [];
	let chargeAmount = 0;
	let error = null;
	let createdDate = new Date(created);
	
	const [notification, setNotification] = useState(null);
	const [operationPending, setOperationPending] = useState(false);
	
	if (!props.invoice) {
		return null;
	}
	
	switch (invoiceType) {
	case 'individual':
		description.push(`Zotero Storage subscription for user ${invoiceUser.username} - ${invoiceUser.email}`);
		description.push(`1 year of Zotero file storage: ${storageLevelDescriptions[storageLevel]}`);
		chargeAmount = priceCents[storageLevel];
		break;
	case 'lab':
		if (institutionName) {
			description.push(`${institutionName}`);
		}
		description.push(`Zotero Lab subscription managed by user ${invoiceUser.username} - ${invoiceUser.email}`);
		description.push(`Zotero Lab subscription will provide one year of unlimited Zotero file storage for ${numUsers} users`);
		chargeAmount = labPrice(numUsers);
		break;
	case 'addLabUsers':
		if (institutionName) {
			description.push(`${institutionName}`);
		}
		description.push(`Add ${numUsers} users to existing Zotero Lab subscription managed by user ${invoiceUser.username} - ${invoiceUser.email}`);
		chargeAmount = labUserPrice(numUsers);
		break;
	case 'contribution':
		break;
	default:
		log.error(invoiceType);
		throw new Error('Unknown invoice type');
	}
	if (invoiceType == 'individual' && overQuota) {
		error = <Alert color='error'>Current usage exceeds the chosen plan&apos;s quota. You&apos;ll need to choose a larger storage plan, or delete some files from your Zotero storage.</Alert>;
	}
	
	let descriptionPs = description.map((d, i) => {
		return <p key={i}>{d}</p>;
	});
	
	/*
	const handleConfirm = async (paymentMethod) => {
		let result;
		setOperationPending(true);
		result = await chargeInvoice(invoiceID, paymentMethod);
		setNotification(result);
		if (result.type == 'success') {
			setStripeChargeObject(result.data.stripeChargeObject);
			setInvoicePaid(true);
			setOperationPending(false);
		}
	};
	*/

	/*
	const handleConfirm = async (paymentMethod) => {
		log.debug('handleConfirm');
		log.debug(paymentMethod);
		if (operationPending) {
			log.debug('operation already pending');
			return;
		}
		let result;
		setOperationPending(true);
		let purchaseData = { invoiceID, type: 'chargePayableInvoice', paymentMethod: paymentMethod.id };// Object.assign({}, purchase, { paymentMethod: paymentMethod.id });
		log.debug(purchaseData);
		let resp;
		try {
			resp = await ajax({
				type: 'POST',
				withSession: true,
				url: '/storage/purchase',
				data: JSON.stringify(purchaseData),
				throwOnError: false,
			});
		} catch (unexpectedThrownResponse) {
			log.error("UNEXPECTED THROWN RESPONSE WHEN ATTEMPTING PURCHASE");
		} finally {
			const respData = await resp.json();
			if (!respData.success) {
				result = {
					type: 'error',
					message: <p>There was an error completing the requested action. Please try again in a few minutes. If you continue to experience problems, email <a href='mailto:storage@zotero.org'>storage@zotero.org</a> with details for assistance.</p>
				};
			} else {
				result = {
					type: 'success',
					message: <span>Invoice Paid</span>,
					data: respData
				};
			}
		}
		setNotification(result);
		if (result.type == 'success') {
			setStripeChargeObject(result.data.stripeChargeObject);
			setInvoicePaid(true);
			setOperationPending(false);
		}
	};
	*/
	const handleConfirm = async (paymentMethod) => {
		log.debug('handleConfirm');
		log.debug(paymentMethod);
		if (operationPending) {
			log.debug('operation already pending');
			return;
		}
		let response;
		let result;
		setOperationPending(true);
		let purchaseData = { invoiceID, type: 'chargePayableInvoice', paymentMethod: paymentMethod.id, paymentMethodType: paymentMethod.type };// Object.assign({}, purchase, { paymentMethod: paymentMethod.id });
		// let purchaseData = Object.assign({}, purchase, { paymentMethod: paymentMethod.id, paymentMethodType: paymentMethod.type });
		log.debug(purchaseData);
		try {
			response = await ajax({
				type: 'POST',
				withSession: true,
				url: '/storage/purchase',
				data: JSON.stringify(purchaseData),
				throwOnError: false,
			});
		} catch (unexpectedThrownResponse) {
			log.error("UNEXPECTED THROWN RESPONSE WHEN ATTEMPTING PURCHASE");
		} finally {
			log.debug('got response from handleConfirm');
			result = await response.json();
			log.debug(result);
			let notifyType = result.success ? 'success' : 'error';
			let notifyMessage = result.message;

			if (!result.success && result.requires_action) {
				const stripe = window.stripe;
				let confirmResult;
				if (paymentMethod.type == 'card') {
					confirmResult = await stripe.confirmCardPayment(result.client_secret);
				} else if (paymentMethod.type == 'sepa_debit') {
					confirmResult = await stripe.confirmSepaDebitPayment(result.client_secret);
				}
				log.debug(confirmResult);
				if (confirmResult.error) {
					log.debug('confirmResult error');
					notifyType = 'error';
				} else if (confirmResult.paymentIntent) {
					log.debug('confirmResult paymentIntent');
					// resumbmit the purchase with the paymentIntent so the subscription gets updated
					let resubPurchaseData = Object.assign({}, purchaseData, { paymentIntentID: confirmResult.paymentIntent.id });
					response = await ajax({
						type: 'POST',
						withSession: true,
						url: '/storage/purchase',
						data: JSON.stringify(resubPurchaseData),
						throwOnError: false,
					});
					log.debug('got response from resubmitted handleConfirm');
					result = await response.json();
					log.debug(result);
					notifyType = result.success ? 'success' : 'error';
					notifyMessage = result.message;
				}
			}

			// refresh(storageDispatch, paymentDispatch);
			setNotification({type: notifyType, message: notifyMessage});
			// notifyDispatch(notify(notifyType, notifyMessage));
			
			if (result.success) {
				setStripeChargeObject(result.stripeChargeObject);
				setInvoicePaid(true);
				setOperationPending(false);
			} else {
				log.error('Payment was not processed successfully');
				log.error(result);
			}
			setOperationPending(false);
		}
	};
	
	
	let blabel = `Pay ${formatCurrency(chargeAmount)}`;
	
	let paymentSection = null;
	if (!invoicePaid) {
		log.debug(description);
		
		/*
		paymentSection = <CardPaymentModal
			stripe={window.stripe}
			{...{ handleConfirm, paymentIntent, chargeAmount, setOperationPending }}
			immediateChargeRequired={true}
			chargeDescription={description}
			buttonLabel={blabel}
			useEmail={true}
		/>;
		*/
		paymentSection = <MultiPaymentModal
			stripe={window.stripe}
			{...{ immediateChargeRequired: true, handleConfirm, paymentIntent, chargeAmount, setOperationPending }}
			chargeDescription={description}
			buttonLabel={blabel}
			useEmail={true}
		/>;

		/*
			stripe={window.stripe}
			handleToken={handleConfirm}
			chargeAmount={chargeAmount}
			chargeDescription={description}
			buttonLabel={blabel}
			useEmail={true}
		/>;
		*/
	} else {
		const paymentMethodDetails = stripeChargeObject.payment_method_details;
		log.debug(paymentMethodDetails);
		log.debug(stripeChargeObject);
		descriptionPs = <p>{stripeChargeObject.description}</p>;
		let datePaid = new Date(stripeChargeObject.created * 1000);
		
		if (paymentMethodDetails) {
			paymentSection = (
				<div className='currentPaymentSource'>
					<Card>
						<CardHeader>
							<h3>Invoice Paid - {datePaid.toLocaleDateString('en-US', dateFormatOptions)}</h3>
						</CardHeader>
						<CardBody>
							<h4>Payment Method</h4>
							<PaymentSource source={paymentMethodDetails} />
						</CardBody>
					</Card>
				</div>
			);
		}
	}
	
	return (
		<ErrorWrapper><PaymentContext.Provider value={{ paymentDispatch, paymentState }}>
			<div className='pay-invoice'>
				<Row>
					<Col sm={{ size: 4, offset: 2 }}>
						<h3>Invoice ID</h3>
						<p>{invoice.invoiceID}</p>
						<p>{createdDate.toLocaleDateString('en-US', dateFormatOptions)}</p>
					</Col>
					<Col sm={4}>
						<h3>Invoice For:</h3>
						<div id='user_info'>
							<p>{invoiceUser.username}</p>
							<p>{invoiceUser.email}</p>
							<p></p>
						</div>
					</Col>
				</Row>
				<Row>
					<Col sm={{ size: 8, offset: 2 }}>
						<Notifier {...notification} />
						<Card className='payment-card'>
							<CardHeader>Zotero Subscription Invoice</CardHeader>
							<CardBody>
								<LoadingSpinner className='m-auto' loading={operationPending} />
								<Card className='mb-4'>
									<CardBody>
										{error}
										{descriptionPs}
									</CardBody>
								</Card>
								{paymentSection}
							</CardBody>
						</Card>
					</Col>
				</Row>
			</div>
		</PaymentContext.Provider></ErrorWrapper>
	);
}

PayInvoice.propTypes = {
	invoice: PropTypes.shape({
		invoiceID: PropTypes.string.isRequired,
		invoiceType: PropTypes.string.isRequired,
		stripeCharge: PropTypes.string,
		userID: PropTypes.number,
		institutionID: PropTypes.number,
		numUsers: PropTypes.number,
		storageLevel: PropTypes.number,
		created: PropTypes.string
	}).isRequired,
	invoiceUser: PropTypes.shape({
		userID: PropTypes.number,
		username: PropTypes.string,
		email: PropTypes.string
	}),
	overQuota: PropTypes.bool,
	stripeCustomer: PropTypes.object,
	stripeChargeObject: PropTypes.shape({
		payment_method_details: PropTypes.object,
		created: PropTypes.number,
	}),
	institutionName: PropTypes.oneOfType([PropTypes.string, PropTypes.bool])
};

export { PayInvoice };
